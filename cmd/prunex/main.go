// chris 082815

// prunex runs a command exclusively.
//
//	usage: prunex command [argument ...]
//
// It is similar to lockf on FreeBSD or flock on Linux.  If the lock
// cannot be acquired (due to another instance holding it), then prunex
// exits immediately.
//
// Lock Files
//
// prunex runs the given command exclusively by means of lock files.
// These are supported on Unix-like systems only (the underlying
// implementation uses golang.org/x/sys/unix.Flock).  The lock files are
// stored in the default temporary directory (via os.TempDir).
//
// A command-specific lock file is generated by producing a a
// deterministic and reasonably human-readable string that identifies
// the command being run.  All non-word characters are consolidated
// between the command and its arguments and are replaced with
// underscores.
//
// If the length of this string exceeds a reasonable limit, then it will
// be truncated and the suffix will be a hash of the full string so as
// to stay within the length limit, but still uniquely and
// deterministically identify the given command and its arguments.
//
// This command-specific lock file is created, used, and removed in a
// race-free manner by means of a "global" lock file, stored in the same
// directory, with name "prunex_global".  This file is not removed
// automatically.
//
// Diagnostics
//
// prunex may return with the following exit codes.
//
//	  1 An unidentified error occurred when trying to run or wait on
//	    the command.
//	  2 Invalid arguments.
//	  4 Could not acquire lock.
//	127 The command could not be found.
//
// And it will print an appropriate message to standard error.
//
// In addition, prunex may return with the following exit code.
//
//	255 The command exited unsuccessfully, but the underlying
//	    operating system does not support examining the exit status.
//
// Otherwise, prunex will return with the exit code of the command.
package main

import (
	"fmt"
	"log"
	"os"

	"path/filepath"

	"chrispennello.com/go/prun/cmd"
	"chrispennello.com/go/util/lockfile"
)

var state struct {
	cmd cmd.State

	// Lock file names.
	globalname string
	localname  string
}

func init() {
	log.SetFlags(0)
	state.cmd = cmd.Parse()

	tmp := os.TempDir()
	key := cmd.MakeKey(state.cmd.Cmd.Name, state.cmd.Cmd.Args)
	state.globalname = filepath.Join(tmp, fmt.Sprintf("%s_global", state.cmd.Me.Name))
	state.localname  = filepath.Join(tmp, fmt.Sprintf("%s_local_%s", state.cmd.Me.Name, key))
}

func main() {
	lc, err := lockfile.LockRm(state.globalname, state.localname)
	if err != nil {
		log.Print(err)
		os.Exit(4)
	}
	defer lc.Unlock()
	proc := cmd.NewProc(state.cmd.Cmd.Name, state.cmd.Cmd.Args)
	proc.Cmd.Stdout = os.Stdout
	proc.Cmd.Stderr = os.Stderr
	proc.StartExit()
	proc.WaitExit()
}
