// chris 082815

// prunex runs a command exclusively.
//
//	usage: prunex command [argument ...]
//
// Lock Files
//
// prunex runs the given command exclusively by means of lock files.
// These are supported on Unix-like systems only (the underlying
// implementation uses golang.org/x/sys/unix.Flock).  The lock files are
// stored in the default temporary directory (via os.TempDir).
//
// A command-specific lock file is generated by producing a a
// deterministic and reasonably human-readable string that identifies
// the command being run.  All non-word characters are consolidated
// between the command and its arguments and are replaced with
// underscores.
//
// If the length of this string exceeds a reasonable limit, then it will
// be truncated and the suffix will be a hash of the full string so as
// to stay within the length limit, but still uniquely and
// deterministically identify the given command and its arguments.
//
// Diagnostics
//
// prunex may return with the following exit codes.
//
//	  1 An unidentified error occurred when trying to run or wait on
//	    the command.
//	  2 Invalid arguments.
//	  4 Could not acquire lock.
//	127 The command could not be found.
//
// And it will print an appropriate message to standard error.
//
// In addition, prunex may return with the following exit code.
//
//	255 The command exited unsuccessfully, but the underlying
//	    operating system does not support examining the exit status.
//
// Otherwise, prunex will return with the exit code of the command.
package main

import (
	"fmt"
	"log"
	"os"

	"path/filepath"

	"chrispennello.com/go/prun/cmd"
	"chrispennello.com/go/util/lockfile"
)

var myargs struct {
	// Name of this program as it's invoked.
	myname string

	// Name of the command to run.
	command string

	// Optional arguments to pass to the program.
	args []string

	// Lock file names.
	globalname string
	localname  string
}

func usage() {
	cmd.BadArgs("usage: %s command [argument ...]\n", myargs.myname)
}

func init() {
	log.SetFlags(0)
	myargs.myname = filepath.Base(os.Args[0])

	if len(os.Args) < 2 {
		usage()
	}

	myargs.command = os.Args[1]
	myargs.args = os.Args[2:]

	tmp := os.TempDir()
	key := cmd.MakeKey(myargs.command, myargs.args)
	myargs.globalname = filepath.Join(tmp, fmt.Sprintf("%s_global", myargs.myname))
	myargs.localname  = filepath.Join(tmp, fmt.Sprintf("%s_local_%s", myargs.myname, key))
}

func main() {
	lc, err := lockfile.LockRm(myargs.globalname, myargs.localname)
	if err != nil {
		log.Print(err)
		os.Exit(4)
	}
	defer lc.Unlock()
	cmd.NewProcExit(myargs.command, myargs.args).WaitExit()
}
