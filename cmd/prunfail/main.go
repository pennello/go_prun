// chris 090415

// prunfail guards the output of a potentially or intermittently failing
// command.
//
//	usage: prunfail maxfail command [argument ...]
//
// prunfail buffers the last 16KiB of standard output and error in
// memory, preventing it from being displayed directly.  If the command
// exits unsuccessfully more than maxfail times, the consolidated
// standard output and error are printed to standard error.  If the
// command exits successfully, the consolidated standard output and
// error are unconditionally printed to standard error, and the failure
// counter is reset.
//
// Sample Usage
//
// Suppose that you have a cron job whose execution depends on an
// intermittently unreliable network API.  One failure here and there
// isn't fatal, but a number of consecutive failures calls for human
// intervention.  You might wrap your cron job with prunfail as follows.
//
//	30 * * * * prunfail 3 your_cron_job
//
// Log File
//
// Failures are tracked by means of a log file.  The last 16KiB of
// standard output and error are always written here, and the size of
// the log file itself is roughly limited to 16KiB.  The log file is
// stored in the default temporary directory (via os.TempDir).  A brief
// footer is always written to the log file, storing the failure count.
//
// The name of the log file is command-specific, and is generated by
// producing a a deterministic and reasonably human-readable string that
// identifies the command being run.  All non-word characters are
// consolidated between the command and its arguments and are replaced
// with underscores.
//
// If the length of this string exceeds a reasonable limit, then it will
// be truncated and the suffix will be a hash of the full string so as
// to stay within the length limit, but still uniquely and
// deterministically identify the given command and its arguments.
//
// Diagnostics
//
// prunex may return with the following exit codes.
//
//	  1 An unidentified error occurred when trying to run or wait on
//	    the command.
//	  2 Invalid arguments.
//	 30 Error redirecting command standard output or error.
//	 31 Error opening, creating, or writing to log file.
//	 32 Error copying consolidated output to standard error.
//	127 The command could not be found.
//
// And it will print an appropriate message to standard error, even if
// the command has not exited unsuccessfully more than maxfail times.
//
// In addition, prunex may return with the following exit code.
//
//	255 The command exited unsuccessfully, but the underlying
//	    operating system does not support examining the exit status.
//
// Otherwise, prunex will return with the exit code of the command.  If
// unsuccessful, the output will be printed only if the command has
// exited unsuccessfully more than maxfail times.
package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"strconv"

	"path/filepath"

	"chrispennello.com/go/prun/cmd"
	"chrispennello.com/go/util/ringbuffer"
)

var state struct {
	cmd cmd.State

	// The maximum number of consecutive failures, after which the
	// output of the most recent failure will be emitted, and the
	// failure count will be reset.
	maxfail int

	// Log file name.
	logname string
}

func init() {
	log.SetFlags(0)
	state.cmd = cmd.Parse("maxfail")

	maxfail, err := strconv.ParseInt(state.cmd.Me.Args[0], 0, 0)
	if err != nil {
		cmd.ArgError(err)
	}
	if maxfail < 1 {
		cmd.BadArgs("maxfail must be positive")
	}
	state.maxfail = int(maxfail)

	tmp := os.TempDir()
	key := cmd.MakeKey(state.cmd.Cmd.Name, state.cmd.Cmd.Args)
	state.logname = filepath.Join(tmp, fmt.Sprintf("%s_%s.log", state.cmd.Me.Name, key))
}

func combinedOutput(proc *cmd.Proc) io.Reader {
	stdout, outerr := proc.Cmd.StdoutPipe()
	if outerr != nil {
		log.Print(outerr)
		os.Exit(30)
	}
	stderr, errerr := proc.Cmd.StderrPipe()
	if errerr != nil {
		log.Print(errerr)
		os.Exit(30)
	}
	return io.MultiReader(stdout, stderr)
}

func write(lf *logFile, rbuf *ringbuffer.B, tostderr bool) {
	data := rbuf.Bytes()
	if err := lf.write(data); err != nil {
		log.Print(err)
		os.Exit(31)
	}

	if tostderr {
		_, err := os.Stderr.Write(data)
		if err != nil {
			log.Print(err)
			os.Exit(32)
		}
	}
}

func exit(lf *logFile, perr *cmd.ProcError, rbuf *ringbuffer.B) {
	lf.failures += 1
	if perr.Msg != "" {
		rbuf.Write([]byte(perr.Msg + "\n"))
	}
	write(lf, rbuf, lf.failures > state.maxfail)
	os.Exit(perr.Code)
}

func main() {
	proc := cmd.NewProc(state.cmd.Cmd.Name, state.cmd.Cmd.Args)

	// Copy combined output from process into ring buffer.  So in
	// the end, if a lot is written, we'll only be left with the
	// last bits.
	cout := combinedOutput(proc)
	rbuf := ringbuffer.New(maxLogSize)
	go func() {
		_, err := io.Copy(rbuf, cout)
		if err != nil {
			log.Print(err)
			os.Exit(30)
		}
	}()

	lf, lferr := newLogFile(state.logname)
	if lferr != nil {
		log.Print(lferr)
		os.Exit(31)
	}

	if perr := proc.StartError(); perr != nil {
		// There aren't any errors that could be caused by just
		// trying to start the process that we should elide.
		perr.Exit()
	}

	if perr := proc.WaitError(); perr != nil {
		// These are the errors that we'll want to potentially elide.
		exit(lf, perr, rbuf)
	}

	// Success: reset the failure count and not only do we log, but
	// the consolidated output also goes unconditionally to standard
	// error.
	lf.failures = 0
	write(lf, rbuf, true)
}
